How to add satellite domains
Warning

This feature is not available in production for free plans, though you can try it out free in development to see if it works for you. See the pricing page for more information.

Create your application and install Clerk
Warning

Currently, multi-domain can be added to any Next.js or Remix application. For other React frameworks, multi-domain is still supported as long as you do not use server rendering or hydration.

To get started, you need to create an application from the Clerk Dashboard. Once you create an instance via the Clerk Dashboard, you will be prompted to choose a domain. This is your primary domain. For the purposes of this guide:

In production, the primary domain will be primary.dev
In development, the primary domain will be localhost:3000.
When building your sign-in flow, you must configure it to run within your primary application, e.g. on /sign-in.

Note

For more information about creating your application, see the setup guide.

Add your first satellite domain
To add a satellite domain:

In the Clerk Dashboard, navigate to the Domains page.
Select the Satellites tab.
Select the Add satellite domain button and follow the instructions provided.
For the purposes of this guide:

In production, the satellite domain will be satellite.dev.
In development, the satellite domain will be localhost:3001.
Configure your satellite app
There are two ways that you can configure your Clerk satellite application to work with the primary domain:

Using environment variables
Using properties
Use the following tabs to select your preferred method. Clerk recommends using environment variables.

Environment variables
Properties
You can configure your satellite application by setting the following environment variables:

Note

In development, your Publishable and Secret Keys will start with pk_test_ and sk_test respectively.

In the .env file associated with your primary domain:

Next.js
Remix
.env

galaxy-test

galaxy-test


NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_a2Vlbi1nbmF0LTg2LmNsZXJrLmFjY291bnRzLmRldiQ
CLERK_SECRET_KEY=sk_test_jXRktyFYMHniXLMmdwX1D9hXstqVEOow3ltiO5FTN3
NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
NEXT_PUBLIC_CLERK_SIGN_UP_URL=/sign-up
In the .env file associated with your other (satellite) domain:

Next.js
Remix
.env

galaxy-test

galaxy-test


NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_a2Vlbi1nbmF0LTg2LmNsZXJrLmFjY291bnRzLmRldiQ
CLERK_SECRET_KEY=sk_test_jXRktyFYMHniXLMmdwX1D9hXstqVEOow3ltiO5FTN3
NEXT_PUBLIC_CLERK_IS_SATELLITE=true
# Production example:
NEXT_PUBLIC_CLERK_DOMAIN=satellite.dev
NEXT_PUBLIC_CLERK_SIGN_IN_URL=https://primary.dev/sign-in
NEXT_PUBLIC_CLERK_SIGN_UP_URL=https://primary.dev/sign-up

# Development example:
# NEXT_PUBLIC_CLERK_DOMAIN=http://localhost:3001
# NEXT_PUBLIC_CLERK_SIGN_IN_URL=http://localhost:3000/sign-in
# NEXT_PUBLIC_CLERK_SIGN_UP_URL=http://localhost:3000/sign-up
You will also need to add the allowedRedirectOrigins property to <ClerkProvider> on your primary domain app to ensure that the redirect back from primary to satellite domain works correctly. For example:

Development
Production
app/layout.tsx

import { ClerkProvider } from '@clerk/nextjs'

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <ClerkProvider allowedRedirectOrigins={['http://localhost:3001']}>{children}</ClerkProvider>
      </body>
    </html>
  )
}
Ready to go 🎉
Your satellite application should now be able to access the authentication state from your satellite domain!

You can see it in action by:

Visiting the primary domain and signing in.
Visiting the satellite domain.
You now have an active session in the satellite domain, so you can see the <UserProfile /> component and update your information.
You can repeat this process and create as many satellite applications as you need.

If you have any questions about satellite domains, or you're having any trouble setting this up, contact





other


clerkMiddleware() | Next.js
The clerkMiddleware() helper integrates Clerk authentication into your Next.js application through Middleware. clerkMiddleware() is compatible with both the App and Pages routers.

Configure clerkMiddleware()
Create a middleware.ts file at the root of your project, or in your src/ directory if you have one.

Note

For more information about Middleware in Next.js, see the Next.js documentation.

middleware.ts

import { clerkMiddleware } from '@clerk/nextjs/server'

export default clerkMiddleware()

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
By default, clerkMiddleware will not protect any routes. All routes are public and you must opt-in to protection for routes.

createRouteMatcher()
createRouteMatcher() is a Clerk helper function that allows you to protect multiple routes. createRouteMatcher() accepts an array of routes and checks if the route the user is trying to visit matches one of the routes passed to it. The paths provided to this helper can be in the same format as the paths provided to the Next Middleware matcher.

The createRouteMatcher() helper returns a function that, if called with the req object from the Middleware, will return true if the user is trying to access a route that matches one of the routes passed to createRouteMatcher().

In the following example, createRouteMatcher() sets all /dashboard and /forum routes as protected routes.


const isProtectedRoute = createRouteMatcher(['/dashboard(.*)', '/forum(.*)'])
Protect API routes
You can protect routes using either or both of the following:

Authentication-based protection: Verify if the user is signed in.
Authorization-based protection: Verify if the user has the required organization roles or custom permissions.
Protect routes based on authentication status
You can protect routes based on a user's authentication status by checking if the user is signed in.

There are two methods that you can use:

Use auth.protect() if you want to redirect unauthenticated users to the sign-in route automatically.
Use auth().userId if you want more control over what your app does based on user authentication status.
auth.protect()
auth().userId()
app/middleware.ts

import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

const isProtectedRoute = createRouteMatcher(['/dashboard(.*)', '/forum(.*)'])

export default clerkMiddleware(async (auth, req) => {
  const { userId, redirectToSignIn } = await auth()

  if (!userId && isProtectedRoute(req)) {
    // Add custom logic to run before redirecting

    return redirectToSignIn()
  }
})

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
Protect routes based on authorization status
You can protect routes based on a user's authorization status by checking if the user has the required roles or permissions.

There are two methods that you can use:

Use auth.protect() if you want Clerk to return a 404 if the user does not have the role or permission.
Use auth().has() if you want more control over what your app does based on the authorization status.
auth.protect()
auth().has()
middleware.ts

import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

const isProtectedRoute = createRouteMatcher(['/admin(.*)'])

export default clerkMiddleware(async (auth, req) => {
  // Restrict admin routes to users with specific permissions
  if (isProtectedRoute(req)) {
    await auth.protect((has) => {
      return has({ permission: 'org:admin:example1' }) || has({ permission: 'org:admin:example2' })
    })
  }
})

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
Protect multiple groups of routes
You can use more than one createRouteMatcher() in your application if you have two or more groups of routes.

The following example uses the has() method from the auth() helper.

middleware.ts

import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

const isTenantRoute = createRouteMatcher(['/organization-selector(.*)', '/orgid/(.*)'])

const isTenantAdminRoute = createRouteMatcher(['/orgId/(.*)/memberships', '/orgId/(.*)/domain'])

export default clerkMiddleware(async (auth, req) => {
  // Restrict admin routes to users with specific permissions
  if (isTenantAdminRoute(req)) {
    await auth.protect((has) => {
      return has({ permission: 'org:admin:example1' }) || has({ permission: 'org:admin:example2' })
    })
  }
  // Restrict organization routes to signed in users
  if (isTenantRoute(req)) await auth.protect()
})

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
Protect all routes
To protect all routes in your application and define specific routes as public, you can use any of the above methods and simply invert the if condition.

middleware.ts

import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

const isPublicRoute = createRouteMatcher(['/sign-in(.*)', '/sign-up(.*)'])

export default clerkMiddleware(async (auth, req) => {
  if (!isPublicRoute(req)) {
    await auth.protect()
  }
})

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
Debug your Middleware
If you are having issues getting your Middleware dialed in, or are trying to narrow down auth-related issues, you can use the debugging feature in clerkMiddleware(). Add { debug: true } to clerkMiddleware() and you will get debug logs in your terminal.

middleware.ts

import { clerkMiddleware } from '@clerk/nextjs/server'

export default clerkMiddleware(
  (auth, req) => {
    // Add your middleware checks
  },
  { debug: true },
)

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
If you would like to set up debugging for your development environment only, you can use the process.env.NODE_ENV variable to conditionally enable debugging. For example, { debug: process.env.NODE_ENV === 'development' }.

Combine Middleware
You can combine other Middleware with Clerk's Middleware by returning the second Middleware from clerkMiddleware().

middleware.ts

import { clerkMiddleware, createRouteMatcher, redirectToSignIn } from '@clerk/nextjs/server'
import createMiddleware from 'next-intl/middleware'

import { AppConfig } from './utils/AppConfig'

const intlMiddleware = createMiddleware({
  locales: AppConfig.locales,
  localePrefix: AppConfig.localePrefix,
  defaultLocale: AppConfig.defaultLocale,
})

const isProtectedRoute = createRouteMatcher(['dashboard/(.*)'])

export default clerkMiddleware(async (auth, req) => {
  if (isProtectedRoute(req)) await auth.protect()

  return intlMiddleware(req)
})

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
clerkMiddleware() options
The clerkMiddleware() function accepts an optional object. The following options are available:

audience?
string | string[]
A string or list of audiences. If passed, it is checked against the aud claim in the token.

authorizedParties?
string[]
An allowlist of origins to verify against, to protect your application from the subdomain cookie leaking attack. For example: ['http://localhost:3000', 'https://example.com']

clockSkewInMs?
number
Specifies the allowed time difference (in milliseconds) between the Clerk server (which generates the token) and the clock of the user's application server when validating a token. Defaults to 5000 ms (5 seconds).

domain?
string
The domain used for satellites to inform Clerk where this application is deployed.

isSatellite?
boolean
When using Clerk's satellite feature, this should be set to true for secondary domains.

jwtKey
string
Used to verify the session token in a networkless manner. Supply the JWKS Public Key from the API keys page in the Clerk Dashboard. It's recommended to use the environment variable instead. For more information, refer to Manual JWT verification.

organizationSyncOptions?
OrganizationSyncOptions | undefined
Used to activate a specific organization or personal account based on URL path parameters. If there's a mismatch between the active organization in the session (e.g., as reported by auth()) and the organization indicated by the URL, the middleware will attempt to activate the organization specified in the URL.

proxyUrl?
string
Specify the URL of the proxy, if using a proxy.

signInUrl
string
The full URL or path to your sign-in page. Needs to point to your primary application on the client-side. Required for a satellite application in a development instance. It's recommended to use the environment variable instead.

signUpUrl
string
The full URL or path to your sign-up page. Needs to point to your primary application on the client-side. Required for a satellite application in a development instance. It's recommended to use the environment variable instead.

publishableKey
string
The Clerk Publishable Key for your instance. This can be found on the API keys page in the Clerk Dashboard.

secretKey?
string
The Clerk Secret Key for your instance. This can be found on the API keys page in the Clerk Dashboard. The CLERK_ENCRYPTION_KEY environment variable must be set when providing secretKey as an option, refer to Dynamic keys.

It's also possible to dynamically set options based on the incoming request:

middleware.ts

import { clerkMiddleware } from '@clerk/nextjs/server'

export default clerkMiddleware(
  (auth, req) => {
    // Add your middleware checks
  },
  (req) => ({
    // Provide `domain` based on the request host
    domain: req.nextUrl.host,
  }),
)
Dynamic keys
Note

Dynamic keys are not accessible on the client-side.

The following options, known as "Dynamic Keys," are shared to the Next.js application server through clerkMiddleware, enabling access by server-side helpers like auth():

signUpUrl
signInUrl
secretKey
publishableKey
Dynamic keys are encrypted and shared during request time using a AES encryption algorithm. When providing a secretKey, the CLERK_ENCRYPTION_KEY environment variable is mandatory and used as the encryption key. If no secretKey is provided to clerkMiddleware, the encryption key defaults to CLERK_SECRET_KEY.

When providing CLERK_ENCRYPTION_KEY, it is recommended to use a 32-byte (256-bit), pseudorandom value. You can use openssl to generate a key:

terminal

openssl rand --hex 32
For multi-tenant applications, you can dynamically define Clerk keys depending on the incoming request. Here's an example:

middleware.ts

import { clerkMiddleware } from '@clerk/nextjs/server'

// You would typically fetch these keys from a external store or environment variables.
const tenantKeys = {
  tenant1: { publishableKey: 'pk_tenant1...', secretKey: 'sk_tenant1...' },
  tenant2: { publishableKey: 'pk_tenant2...', secretKey: 'sk_tenant2...' },
}

export default clerkMiddleware(
  (auth, req) => {
    // Add your middleware checks
  },
  (req) => {
    // Resolve tenant based on the request
    const tenant = getTenant(req)
    return tenantKeys[tenant]
  },
)
OrganizationSyncOptions
The organizationSyncOptions property on the clerkMiddleware() options object has the type OrganizationSyncOptions, which has the following properties:

organizationPatterns
Pattern[]
Specifies URL patterns that are organization-specific, containing an organization ID or slug as a path parameter. If a request matches this path, the organization identifier will be used to set that org as active.

If the route also matches the personalAccountPatterns prop, this prop takes precedence.

Patterns must have a path parameter named either :id (to match a Clerk organization ID) or :slug (to match a Clerk organization slug).

Warning

If the organization can't be activated—either because it doesn't exist or the user lacks access—the previously active organization will remain unchanged. Components must detect this case and provide an appropriate error and/or resolution pathway, such as calling notFound() or displaying an <OrganizationSwitcher />.

Common examples:

["/orgs/:slug", "/orgs/:slug/(.*)"]
["/orgs/:id", "/orgs/:id/(.*)"]
["/app/:any/orgs/:slug", "/app/:any/orgs/:slug/(.*)"]
personalAccountPatterns
Pattern[]
URL patterns for resources that exist within the context of a Clerk Personal Account (user-specific, outside any organization).

If the route also matches the organizationPattern prop, the organizationPattern prop takes precedence.

Common examples:

["/me", "/me/(.*)"]
["/user/:any", "/user/:any/(.*)"]
Pattern
A Pattern is a string that represents the structure of a URL path. In addition to any valid URL, it may include:

Named path parameters prefixed with a colon (e.g., :id, :slug, :any).
Wildcard token, (.*), which matches the remainder of the path.
Examples
/orgs/:slug
URL	Matches	:slug value
/orgs/acmecorp	✅	acmecorp
/orgs	❌	n/a
/orgs/acmecorp/settings	❌	n/a
/app/:any/orgs/:id
URL	Matches	:id value
/app/petstore/orgs/org_123	✅	org_123
/app/dogstore/v2/orgs/org_123	❌	n/a
/personal-account/(.*)
URL	Matches
/personal-account/settings	✅
/personal-account	❌
lerk Next.js SDK
The Clerk Next.js SDK gives you access to prebuilt components, React hooks, and helpers to make user authentication easier. Refer to the quickstart guide to get started.

Client-side helpers
Because the Next.js SDK is built on top of the Clerk React SDK, you can use the hooks that the React SDK provides. These hooks include access to the Clerk object, User object, Organization object, and a set of useful helper methods for signing in and signing up.

useUser()
useClerk()
useAuth()
useSignIn()
useSignUp()
useSession()
useSessionList()
useOrganization()
useOrganizationList()
Server-side helpers
App router
Clerk provides first-class support for the Next.js App Router. The following references show how to integrate Clerk features into apps using the latest App Router and React Server Components features.

auth()
currentUser()
Route Handlers
Server Actions
Pages router
Clerk continues to provide drop-in support for the Next.js Pages Router. In addition to the main Clerk integration, the following references are available for apps using Pages Router.

getAuth()
buildClerkProps()
Auth object
Both auth() (App Router) and getAuth() (Pages Router) return an Auth object. This JavaScript object contains important information like the current user's session ID, user ID, and organization ID. Learn more about the Auth object.

clerkMiddleware()
The clerkMiddleware() helper integrates Clerk authentication into your Next.js application through middleware. It allows you to integrate authorization into both the client and server of your application. You can learn more here.

Demo repositories
For examples of Clerk's features, such as user and organization management, integrated into a single application, see the Next.js demo repositories:

Clerk + Next.js App Router Demo
Clerk + Next.js Pages Router Demoauth()
The auth() helper returns the Auth object of the currently active user, as well as the redirectToSignIn() method.

Only available for App Router.
Only works on the server-side, such as in Server Components, Route Handlers, and Server Actions.
Requires clerkMiddleware() to be configured.
auth.protect()
auth includes a single property, the protect() method, which you can use in two ways:

to check if a user is authenticated (signed in)
to check if a user is authorized (has the correct roles or permissions) to access something, such as a component or a route handler
The following table describes how auth.protect() behaves based on user authentication or authorization status:

Authenticated	Authorized	auth.protect() will
Yes	Yes	Return the Auth object.
Yes	No	Return a 404 error.
No	No	Redirect the user to the sign-in page*.
Important

For non-document requests, such as API requests, auth.protect() returns a 404 error to users who aren't authenticated.

auth.protect() accepts the following parameters:

role?
string
The role to check for.

permission?
string
The permission to check for.

has?
(isAuthorizedParams: CheckAuthorizationParamsWithCustomPermissions) => boolean
A function that checks if the user has an organization role or custom permission. See the reference for more information.

unauthorizedUrl?
string
The URL to redirect the user to if they are not authorized.

unauthenticatedUrl?
string
The URL to redirect the user to if they are not authenticated.

Example
auth.protect() can be used to check if a user is authenticated or authorized to access certain parts of your application or even entire routes. See detailed examples in the dedicated guide.

redirectToSignIn()
The auth() helper returns the redirectToSignIn() method, which you can use to redirect the user to the sign-in page.

redirectToSignIn() accepts the following parameters:

returnBackUrl?
string | URL
The URL to redirect the user back to after they sign in.

Note

auth() on the server-side can only access redirect URLs defined via environment variables or clerkMiddleware dynamic keys.

Example
The following example shows how to use redirectToSignIn() to redirect the user to the sign-in page if they are not authenticated. It's also common to use redirectToSignIn() in clerkMiddleware() to protect entire routes; see the clerkMiddleware() docs for more information.

app/page.tsx

import { auth } from '@clerk/nextjs/server'

export default async function Page() {
  const { userId, redirectToSignIn } = await auth()

  if (!userId) return redirectToSignIn()

  return <h1>Hello, {userId}</h1>
}
auth() usage
Protect pages and routes
You can use auth() to check if a userId exists. If it's null, then there is not an authenticated (signed in) user. See detailed examples in the dedicated guide.

Check roles and permissions
You can use auth() to check if a user is authorized to access certain parts of your application or even entire routes by checking their roles or permissions. See detailed examples in the dedicated guide.

Data fetching with getToken()
If you need to send a JWT along to a server, getToken() retrieves the current user's session token or a custom JWT template. See detailed examples in the Auth reference.

Feedback
What did you think of this content?currentUser()
The currentUser helper returns the Backend User object of the currently active user. It can be used in Server Components, Route Handlers, and Server Actions.

Under the hood, this helper:

calls fetch(), so it is automatically deduped per request.
uses the GET /v1/users/{user_id} endpoint.
counts towards the Backend API request rate limit.
app/page.tsx

import { currentUser } from '@clerk/nextjs/server'

export default async function Page() {
  const user = await currentUser()

  if (!user) return <div>Not signed in</div>

  return <div>Hello {user?.firstName}</div>
}Route Handlers
Clerk provides helpers that allow you to protect your Route Handlers, fetch the current user, and interact with the Clerk Backend API.

Protect your Route Handlers
If you aren't protecting your Route Handler using clerkMiddleware(), you can protect your Route Handler in two ways:

Use auth.protect() if you want Clerk to return a 404 error when there is no signed in user.
Use auth().userId if you want to customize the behavior or error message.
auth.protect()
auth().userId()
app/api/route.ts

import { auth } from '@clerk/nextjs/server'
import { NextResponse } from 'next/server'

export async function GET() {
  const { userId } = await auth()

  if (!userId) {
    return NextResponse.json({ error: 'Error: No signed in user' }, { status: 401 })
  }

  // Add your Route Handler logic here

  return NextResponse.json({ userId })
}
Retrieve data from external sources
Clerk provides integrations with a number of popular databases.

The following example demonstrates how to use auth().getToken() to retrieve a token from a JWT template and use it to fetch data from the external source.

app/api/route.ts

import { NextResponse } from 'next/server'
import { auth } from '@clerk/nextjs/server'
export async function GET() {
  const { userId, getToken } = await auth()

  if (!userId) {
    return new Response('Unauthorized', { status: 401 })
  }

  const token = await getToken({ template: 'supabase' })

  // Fetch data from Supabase and return it.
  const data = { supabaseData: 'Hello World' }

  return NextResponse.json({ data })
}
Retrieve the current user
In some cases, you might need the current user in your Route Handler. Clerk provides an asynchronous helper called currentUser() to retrieve the current Backend User object.

app/api/route.ts

import { NextResponse } from 'next/server'
import { currentUser } from '@clerk/nextjs/server'
export async function GET() {
  const user = await currentUser()

  if (!user) {
    return new Response('Unauthorized', { status: 401 })
  }

  return NextResponse.json({ user })
}
Interact with Clerk's Backend API
The JavaScript Backend SDK exposes the Backend API resources and low-level authentication utilities for JavaScript environments.

clerkClient exposes an instance of the JavaScript Backend SDK for use in server environments.

app/api/route.ts

import { NextResponse, NextRequest } from 'next/server'
import { auth, clerkClient } from '@clerk/nextjs/server'

export async function POST(req: NextRequest) {
  const { userId } = await auth()

  if (!userId) return NextResponse.redirect(new URL('/sign-in', req.url))

  const params = { firstName: 'John', lastName: 'Wick' }

  const client = await clerkClient()

  const user = await client.users.updateUser(userId, params)

  return NextResponse.json({ user })
}
Feedback
What did you think of this content?erver Actions
Clerk provides helpers to allow you to protect your Server Actions, fetch the current user, and interact with the Clerk API.

The following guide provides examples for using Server Actions in Server Components and in Client Components.

With Server Components
Protect your Server Actions
You can use the auth() helper to protect your server actions. This helper will return the current user's ID if they are signed in, or null if they are not.

actions.ts

import { auth } from '@clerk/nextjs/server'

export default function AddToCart() {
  async function addItem(formData: FormData) {
    'use server'

    const { userId } = await auth()

    if (!userId) {
      throw new Error('You must be signed in to add an item to your cart')
    }

    console.log('add item server action', formData)
  }

  return (
    <form action={addItem}>
      <input value={'test'} type="text" name="name" />
      <button type="submit">Add to Cart</button>
    </form>
  )
}
Accessing the current user
Current user data is important for data enrichment. You can use the currentUser() helper to fetch the current user's data in your server actions.

app/page.tsx

import { currentUser } from '@clerk/nextjs/server'

export default function AddHobby() {
  async function addHobby(formData: FormData) {
    'use server'

    const user = await currentUser()

    if (!user) {
      throw new Error('You must be signed in to use this feature')
    }

    const serverData = {
      usersHobby: formData.get('hobby'),
      userId: user.id,
      profileImage: user.imageUrl,
    }

    console.log('add item server action completed with user details ', serverData)
  }

  return (
    <form action={addHobby}>
      <input value={'soccer'} type="text" name="hobby" />
      <button type="submit">Submit your hobby</button>
    </form>
  )
}
With Client Components
When using Server Actions in Client Components, you need to make sure you use prop drilling to ensure that headers are available.

Protect your Server Actions
Use the following tabs to see an example of how to protect a Server Action that is used in a Client Component.

Server Action
Client Component
Page
app/actions.ts

'use server'
import { auth } from '@clerk/nextjs/server'

export async function addItem(formData: FormData) {
  const { userId } = await auth()

  if (!userId) {
    throw new Error('You must be signed in to add an item to your cart')
  }

  console.log('add item server action', formData)
}
Accessing the current user
Use the following tabs to see an example of how to access the current user in a Server Action that is used in a Client Component.

Server Action
Client Component
Page
app/actions.ts

'use server'
import { currentUser } from '@clerk/nextjs/server'

export async function addHobby(formData: FormData) {
  const user = await currentUser()

  if (!user) {
    throw new Error('You must be signed in to use this feature')
  }

  const serverData = {
    usersHobby: formData.get('hobby'),
    userId: user.id,
    profileImage: user.imageUrl,
  }

  console.log('add Hobby completed with user details ', serverData)
}
afterSignXUrl changes
Note

This section refers to afterSignXUrl where X could be Up or In depending on the context.

All afterSignXUrl props and CLERK_AFTER_SIGN_X_URL environment variables have been deprecated, and should be replaced by one of the following options:

CLERK_SIGN_X_FORCE_REDIRECT_URL / signXForceRedirectUrl – If set, Clerk will always redirect to provided URL, regardless of what page the user was on before. Use this option with caution, as it will interrupt the user's flow by taking them away from the page they were on before.
CLERK_SIGN_X_FALLBACK_REDIRECT_URL / signXFallbackRedirectUrl – If set, this will mirror the previous behavior, only redirecting to the provided URL if there is no redirect_url in the querystring.
In general, use the environment variables over the props.

Warning

If neither value is set, Clerk will redirect to the redirect_url if present, otherwise it will redirect to /.

To retain the current behavior of your app without any changes, you can switch afterSignXUrl with signXFallbackRedirectUrl as such:


<SignIn afterSignInUrl="/foo" />
<SignIn signInFallbackRedirectUrl="/foo" />